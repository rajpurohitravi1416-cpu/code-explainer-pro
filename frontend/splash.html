<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Code Explainer â€” Splash (stable text + redirect)</title>

<!-- Three.js + GSAP -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>

<style>
  :root{ --bg1:#04030a; --bg2:#071226 }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#fff}
  #container{position:fixed;inset:0;overflow:hidden}
  .hint{position:fixed;top:14px;left:50%;transform:translateX(-50%);z-index:60;padding:8px 12px;background:rgba(0,0,0,0.28);border-radius:999px;border:1px solid rgba(255,255,255,0.03);font-size:13px}
  .orbBtn{
    position:fixed; z-index:70; width:160px; height:160px; left:50%; top:44%;
    transform:translate(-50%,-50%);
    border-radius:50%; cursor:pointer; border:1px solid rgba(255,255,255,0.03);
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.06), rgba(0,0,0,0.06)),
                linear-gradient(135deg,#b884ff,#9b60ff);
    box-shadow: 0 30px 100px rgba(155,100,255,0.12), inset 0 -12px 28px rgba(0,0,0,0.38);
  }
  .orbBtn:active{ transform:translate(-50%,-48%) scale(.996) }
  @media(max-width:520px){ .orbBtn{ width:120px; height:120px; top:40% } canvas{height:56vh} }
</style>
</head>
<body>
  <div id="container"></div>
  <div class="hint">Tap / click the orb (or press Space / Enter)</div>
  <button id="orbBtn" class="orbBtn" aria-label="Open splash"></button>

<script>
/* "Code Explainer" splash
   - Text: "Code Explainer"
   - Sphere rotates only while in 'sphere' state
   - After triggering morph, text is stable (no spin)
   - Redirects to login.html exactly 3 seconds after morph starts
*/

const TEXT = "Code Explainer";
const COUNT = 8000;
const SPAWN_RADIUS = 9;
const TEXT_SCALE = 0.32;

let scene, camera, renderer, particles;
let positionsAttr;
let currentState = 'sphere'; // 'sphere' or 'text'
const container = document.getElementById('container');

function sphericalPoint(i, total, radius){
  const u = (i + 0.5) / total;
  const phi = Math.acos(1 - 2 * u);
  const theta = Math.PI * (1 + Math.sqrt(5)) * i;
  const x = radius * Math.sin(phi) * Math.cos(theta);
  const y = radius * Math.sin(phi) * Math.sin(theta);
  const z = radius * Math.cos(phi);
  return { x, y, z };
}

function init(){
  scene = new THREE.Scene();
  const w = window.innerWidth, h = window.innerHeight;
  camera = new THREE.PerspectiveCamera(50, w/h, 0.1, 1000);
  camera.position.z = 34;

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(w, h);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  container.appendChild(renderer.domElement);

  // create points
  const geom = new THREE.BufferGeometry();
  const pos = new Float32Array(COUNT * 3);
  const colors = new Float32Array(COUNT * 3);
  for (let i = 0; i < COUNT; i++){
    const p = sphericalPoint(i, COUNT, SPAWN_RADIUS);
    pos[i*3]   = p.x + (Math.random()-0.5) * 0.4;
    pos[i*3+1] = p.y + (Math.random()-0.5) * 0.4;
    pos[i*3+2] = p.z + (Math.random()-0.5) * 0.4;
    const depth = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z) / SPAWN_RADIUS;
    const col = new THREE.Color();
    col.setHSL(0.78 - depth*0.05, 0.68 - depth*0.08, 0.5 + depth*0.1);
    colors[i*3] = col.r; colors[i*3+1] = col.g; colors[i*3+2] = col.b;
  }
  geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  positionsAttr = geom.getAttribute('position');

  const mat = new THREE.PointsMaterial({
    size: 0.12,
    vertexColors: true,
    transparent: true,
    opacity: 0.98,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    sizeAttenuation: true
  });
  particles = new THREE.Points(geom, mat);
  scene.add(particles);

  animate();
  window.addEventListener('resize', onResize);
}

function sampleTextTargets(text){
  const off = document.createElement('canvas');
  const offCtx = off.getContext('2d');
  const width = Math.min(2000, Math.max(600, window.innerWidth * 1.0));
  const height = Math.min(480, Math.max(140, window.innerHeight * 0.34));
  off.width = width; off.height = height;

  const fontSize = Math.floor(Math.min(height * 0.78, width / Math.max(8, text.length) * 1.05));
  offCtx.fillStyle = '#000'; offCtx.fillRect(0,0,off.width,off.height);
  offCtx.font = `bold ${fontSize}px "Fira Code", monospace`;
  offCtx.textAlign = 'center'; offCtx.textBaseline = 'middle';
  offCtx.fillStyle = '#fff';
  offCtx.fillText(text, off.width/2, off.height/2);

  const img = offCtx.getImageData(0,0,off.width,off.height);
  const gap = Math.max(3, Math.round(3 * (window.devicePixelRatio || 1)));
  const pts = [];

  for (let y = 0; y < off.height; y += gap){
    for (let x = 0; x < off.width; x += gap){
      const idx = (y * off.width + x) * 4;
      const bright = (img.data[idx] + img.data[idx+1] + img.data[idx+2]) / 3;
      if (bright > 40){
        const sx = (x / off.width - 0.5) * (Math.min(window.innerWidth, 1400) * 0.78) / (fontSize/28);
        const sy = -(y / off.height - 0.5) * (off.height / (fontSize/12));
        pts.push({ x: sx * TEXT_SCALE, y: sy * TEXT_SCALE });
      }
    }
  }

  for (let i = pts.length - 1; i > 0; i--){
    const j = Math.floor(Math.random()*(i+1));
    [pts[i], pts[j]] = [pts[j], pts[i]];
  }
  return pts;
}

function morphPositions(newTargets, duration = 1.9){
  const pos = positionsAttr.array;
  const start = new Float32Array(pos.length);
  start.set(pos);

  const targ = new Float32Array(pos.length);
  for (let i = 0; i < COUNT; i++){
    if (i < newTargets.length){
      targ[i*3]     = newTargets[i].x;
      targ[i*3 + 1] = newTargets[i].y;
      targ[i*3 + 2] = 0;
    } else {
      const a = Math.random() * Math.PI * 2;
      const r = 10 + Math.random() * 10;
      targ[i*3]     = Math.cos(a) * r + (Math.random()-0.5) * 0.8;
      targ[i*3 + 1] = Math.sin(a) * r + (Math.random()-0.5) * 0.8;
      targ[i*3 + 2] = (Math.random()-0.5) * 5;
    }
  }

  const obj = { t: 0 };
  gsap.to(obj, {
    t: 1,
    duration: duration,
    ease: "power2.inOut",
    onUpdate: () => {
      for (let i = 0; i < pos.length; i++){
        pos[i] = start[i] + (targ[i] - start[i]) * obj.t;
      }
      positionsAttr.needsUpdate = true;
    }
  });
}

function animate(){
  requestAnimationFrame(animate);
 if (particles) {
    if (currentState === 'sphere') {
        // rotate sphere only
        particles.rotation.y += 0.0016;
        particles.rotation.x += 0.00015;
    } else {
        // stop ALL rotation during text
        particles.rotation.x = 0;
        particles.rotation.y = 0;
        particles.rotation.z = 0;
    }
}

  renderer.render(scene, camera);
}

function onResize(){
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w/h; camera.updateProjectionMatrix();
  renderer.setSize(w, h);
}

/* Interaction + redirect */
let triggered = false;
const orbBtnEl = document.getElementById('orbBtn');

async function triggerMorphFlow(){
  if (triggered) return;
  triggered = true;

  // hide orb overlay
  orbBtnEl.style.transition = 'opacity .36s, transform .36s';
  orbBtnEl.style.opacity = '0';
  orbBtnEl.style.transform = 'translate(-50%,-56%) scale(.96)';
  setTimeout(()=> orbBtnEl.style.display = 'none', 360);

  // set state to text so rotation stops
  currentState = 'text';

  // morph to text
  const pts = sampleTextTargets(TEXT);
  const usePts = pts.length > COUNT ? pts.slice(0, COUNT) : pts;
  morphPositions(usePts, 1.9);

  // redirect to login.html exactly 3 seconds after morph starts
  setTimeout(() => { window.location.href = 'login.html'; }, 3000);
}

orbBtnEl.addEventListener('click', () => triggerMorphFlow().catch(e=>console.error(e)));
window.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter'){ e.preventDefault(); triggerMorphFlow().catch(e=>console.error(e)); }
});

init();
</script>
</body>
</html>
